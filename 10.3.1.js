any = prompt('Введите значение');
!any == Number;
typeof any == Number;
any.isNaN

if (any % 2) {
alert('Нечетное')
}
else if(any % 3) {
alert('Четное')
}
else if (any != Number) {
alert('Упс, кажется, вы ошиблись')
}

// По факту код работает верно, но довольно странным способом :) Если вы просто экспериментируете, то хорошо, но на всякий случай написала внизу более простой и оптимальный вариант решения + объяснения:

const inputValue = prompt('Введите число')

const value = +inputValue;

if(typeof value === "number" && !isNaN(value)){
  if (value % 2 === 0){
    console.log('чётное')
  } else {
    console.log('нечётное')
  }
} else {
  console.log('Упс, кажется, вы ошиблись')
}

// Что смутило в вашем решении: 
// 1. Отсутствует приведение к числовому типу с помощью унарного плюса (в примере это вот эта строчка - const value = +inputValue;). 
// 2. Нет проверки на тип и на NaN. Эти строчки:
// !any == Number;
// typeof any == Number;
// any.isNaN
// не проверяют тип значения
// 3. Неправильно оформлены логические условия в блоке if: например, any % 2 должно с чем-то сравниваться, иначе условие теряет смысл. Правильно так: any % 2 === 0, т.е. берем остаток от деления переменной на 2 и сравниваем с нулем.
// 4. Данная строчка - any != Number - не является проверкой на тип, такой код не сработает. Number - это объект-обертка для всех числовых значений, он используется для других целей. Кроме того, сейчас вы сравниваете с number значение переменной any, а не нё тип. Для определения типа используется typeof. Верная проверка выглядит так: typeof any === "number"