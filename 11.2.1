var arr = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711];

var numb = function(arr) {
    var arr1 = [];
    var arr2 = [];
        for (var i in arr) {
            
            if (!isNaN(arr[i])) {
                
                if (arr[i] % 2 == 0) {
                    arr2.push(arr[i]);
                } else {
                    arr1.push(arr[i]);
                }
            }
        }
    console.log (arr1, arr2);
}
document.write(numb(arr));

======
Задание выполнено не верно. По условию вам нужно было считать кол-во четных и нечетных элементов, не разделять их на 2 разных массива. Кроме того, нулевые элементы (т.е. число 0) нужно было учитывать отдельно.
Ещё одна ошибка - отсутствие проверки на тип (т.к. учитывать нужно только числа). У вас стоит проверка на NaN, но её недостаточно. Значения NaN учтены не будут, но все остальные нечисловые значения - строки, true, false, null, undefined и т.д. проверку пройдут, хотя они должны быть отсеяны. Ниже написала верный вариант решения

const arr = [0, null, NaN, 0, 1, 2, 4, "str", true, false, "55"]

function getTypeOfNumbers() {

    let even = 0, odd = 0, zero = 0;

    for (let i = 0; i < arr.length; i++) {
        if (typeof arr[i] === 'number' && !isNaN(arr[i])) {
            if (arr[i] === 0) {
                zero += 1;
            } else if (arr[i] % 2 === 0) {
                even += 1;
            } else {
                odd += 1;
            }
        }
    }

    console.log('четных элементов: ', even);
    console.log('нечетных элементов: ', odd);
    console.log('нулей: ', zero);
}

getTypeOfNumbers(arr);
